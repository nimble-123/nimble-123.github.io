<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: raspberrypi | Just My Two Cents]]></title>
  <link href="http://nlsltz.github.io/blog/categories/raspberrypi/atom.xml" rel="self"/>
  <link href="http://nlsltz.github.io/"/>
  <updated>2014-11-22T20:51:13+01:00</updated>
  <id>http://nlsltz.github.io/</id>
  <author>
    <name><![CDATA[Nils Lutz]]></name>
    <email><![CDATA[info@nilslutz.de]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[OpenVPN auf dem RaspberryPi einrichten]]></title>
    <link href="http://nlsltz.github.io/2014/10/21/openvpn-auf-dem-raspberry-pi-einrichten/"/>
    <updated>2014-10-21T17:00:00+02:00</updated>
    <id>http://nlsltz.github.io/2014/10/21/openvpn-auf-dem-raspberry-pi-einrichten</id>
    <content type="html"><![CDATA[<p><img class="right" src="/images/openvpn.png" width="200" height="200" title="&lsquo;OpenVPN Logo&rsquo; &lsquo;OpenVPN Logo&rsquo;" >Da man in letzter Zeit ja immer öfters hört, wie wir alle massenweise ausspioniert werden. War es an der Zeit mein Netzwerk Zuhause ein wenig mehr abzusichern. Ich habe auch gerne Zugriff auf meine Geräte von außerhalb. Um einerseits den Status meines Pi zu überprüfen oder aber um meinem Medien Server bei Bedarf zu starten. Bisher hatte ich immer fahrlässig meinen Port <code>22</code> vom Pi ins Internet geöffnet.<!-- more --></p>

<p>Da das aber jedem mit auch nur ein bisschen Skill die Türen zu meinem Netzwerk öffnete, sollte dieser Umstand so schnell es geht behoben werden. So kam <a href="https://openvpn.net/">OpenVPN</a> auf den Plan. OpenVPN ist eine Open Source Applikation, die mit SSL/TLS verschlüsselt und auch Clients für sämtliche Plattformen(Android, iOS, Windows, OS X, Linux) anbietet. Nachfolgend erkläre ich die Installation des Servers auf dem Raspberry Pi, sowie die Client Konfiguration.</p>

<h2>Schritt 1</h2>

<p>OpenVPN und OpenSSL Pakete auf dem Pi installieren.</p>

<pre><code class="bash">sudo apt-get install openvpn opensll
</code></pre>

<h2>Schritt 2</h2>

<p>Damit die Schlüssel für die Authentifizierung generiert werden können nutzen wir die mitgelieferte Easy-RSA Skripte. Bevor wir sie allerdings nutzen kopieren wir sie in das Konfigurationsverzeichnis von OpenVPN.</p>

<pre><code class="bash">sudo cp -r /usr/share/doc/openvpn/examples/easy-rsa/2.0 /etc/openvpn/easy-rsa
</code></pre>

<h2>Schritt 3</h2>

<p>Als nächsten werden die Grundeinstellungen an unsere Bedürfnisse angepasst. Dies geschieht in der Datei <code>/etc/openvpn/easy-rsa/vars</code>. In Zeile 15 muss das Verzeichnis von Easy-RSA angegeben werden. Zusätzlich ändern wir noch in Zeile 53 die Schlüssellänge auf 2048bit.
<code>bash
export EASY_RSA="/etc/openvpn/easy-rsa"
</code>
<code>bash
export KEY_SIZE=2048
</code></p>

<h2>Schritt 4</h2>

<p>Wir wechseln ins Easy-RSA Verzeichnis und versorgen uns mit Root Rechten.
<code>bash
cd /etc/openvpn/easy-rsa
sudo su
source vars
</code></p>

<p>Weiter benötigen die Easy-RSA Skripte eine OpenSSL Konfiguration, welche wir uns einfach mit einem symbolischen Link erstellen
<code>bash
ln -s openssl-1.0.0.cnf openssl.cnf
</code></p>

<h2>Schritt 5</h2>

<p>So da nun alles eingestellt ist können wir damit beginnen die Zertifikate und Schlüssel zu erzeugen.</p>

<p>Der zweite Befehl fragt eine Reihe von Informationen ab. Lediglich das Land ist wichtig für unsere Konfiguration, der Rest kann außer Acht gelassen werden.
<code>bash
./clean-all
./build-ca &lt;NAME DES VPNs&gt;
</code></p>

<p>Der nächste Befehl erzeugt aus dem zuvor erstellten Root Zertifikat einen Schlüssel für den Server. Auch hier werden wieder einige Informationen abgefragt. Das <code>Challenge Password</code> kann leer gelassen werden.
<code>bash
./build-key-server server
</code></p>

<p>Zu letzt werden noch die Diffie-Hellman-Parameter generiert. Dadurch wird ein sicherer Schlüsselaustausch ermöglicht.
<code>bash
./build-dh
exit
</code></p>

<h2>Schritt 6</h2>

<p>Zertifikate und Schlüssel sind generiert. Also können wir uns jetzt um die OpenVPN Server Konfiguration kümmern.
<code>bash
sudo nano /etc/openvpn/openvpn.conf
</code></p>

<p>In diese Datei gehört folgender Inhalt. Es werden die Orte der Zertifikate und Schlüssel angegeben. Die verwendeten Verschlüsselungsmodi lassen sich auch hier einstellen.</p>

<pre><code class="bash">mode server
tls-server

# virtual interface for vpn
dev tun

# protocol for port
proto udp

# port for vpn
port 1194

# keys and certificates
ca /etc/openvpn/easy-rsa/keys/ca.crt
cert /etc/openvpn/easy-rsa/keys/server.crt
key /etc/openvpn/easy-rsa/keys/server.key
dh /etc/openvpn/easy-rsa/keys/dh2048.pem

# tls-auth server
key-direction 0
tls-auth /etc/openvpn/easy-rsa/keys/ta.key

# cipher suites
cipher AES-256-CBC
auth SHA512
tls-cipher DHE-RSA-AES256-SHA

# user and group
user nobody
group nogroup 

# used subnet for vpn
server 10.0.1.0 255.255.255.0

# persistance
persist-key
persist-tun

# logging
status /var/log/openvpn-status.log
verb 3
log-append /var/log/openvpn

# routing
client-to-client
push "redirect-gateway def1 bypass-dhcp"
push "dhcp-option DNS 85.214.20.141"
push "dhcp-option DNS 8.8.8.8"

# compression
comp-lzo

# keep vpn session alive
keepalive 10 120

# user auth with username/password
;plugin /usr/lib/openvpn/openvpn-auth-pam.so login
;client-cert-not-required;
;username-as-common-name

# certificate revocation list
;crl-verify /etc/openvpn/crl.pem
</code></pre>

<h2>Schritt 7</h2>

<p>Damit man vom Client auch eine Verbindung ins Internet über den OpenVPN Server bekommt muss eine Weiterleitung in der Firewall eingestellt werden. Diese Einstellung soll einen Neustart des Servers überstehen weshalb wir uns das folgende Skript anlegen.</p>

<pre><code class="bash">sudo nano /etc/init.d/rpivpn
</code></pre>

<pre><code class="bash">#! /bin/sh
### BEGIN INIT INFO
# Provides:          rpivpn
# Required-Start:    $remote_fs $syslog
# Required-Stop:     $remote_fs $syslog
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: VPN initialisation script
### END INIT INFO

echo 'echo "1"  &gt; /proc/sys/net/ipv4/ip_forward' | sudo -s
sudo iptables -A INPUT -i tun+ -j ACCEPT
sudo iptables -A FORWARD -i tun+ -j ACCEPT
sudo iptables -A FORWARD -m state --state ESTABLISHED,RELATED -j ACCEPT
sudo iptables -t nat -F POSTROUTING
sudo iptables -t nat -A POSTROUTING -s 10.0.1.0/24 -o eth0 -j MASQUERADE
</code></pre>

<p>Nur noch die Rechte anpassen und dann einmal per Hand ausführen. Zusätzlich kommt das Skript noch in den Autostart.</p>

<pre><code class="bash">sudo chmod +x /etc/init.d/rpivpn
sudo update-rc.de rpivpn defaults
sudo /etc/init.d/rpivpn
sudo /etc/init.d/openvpn restart
</code></pre>

<h2>Schritt 8</h2>

<p>Damit wäre die Arbeit für den OpenVPN Server erledigt. Widmen wir uns nun der Client Konfiguration. Erstmal benötigen wir wieder Root Rechte und dann erzeugen wir uns ein Skript um automatisiert Client Konfigurationen erstellen zu können. Lediglich der Speicherort der fertigen Konfiguration muss angepasst werden im Skript.</p>

<pre><code class="bash">sudo su
cd /etc/openvpn/easy-rsa/
nano build-client-config
</code></pre>

<pre><code class="bash">#! /bin/bash
# Script to automate creating new OpenVPN clients
# The client cert and key, along with the CA cert is
# zipped up and placed somewhere to download securely
#
# H Cooper - 05/02/11
# 
# edited by: N Lutz - 17.10.2014 info@nilslutz.de
#
# Usage: build-client-config &lt;common-name&gt;

# Set where we're working from
OPENVPN_DIR=/etc/openvpn
OPENVPN_RSA_DIR=/etc/openvpn/easy-rsa
OPENVPN_KEYS=$OPENVPN_RSA_DIR/keys
KEY_DOWNLOAD_PATH=&lt;OVPN SPEICHERORT&gt;

# Either read the CN from $1 or prompt for it
if [ -z "$1" ]
    then echo -n "Enter new client common name (CN): "
    read -e CN
else
    CN=$1
fi

# Ensure CN isn't blank
if [ -z "$CN" ]
    then echo "You must provide a CN."
    exit
fi

# Check the CN doesn't already exist
if [ -f $OPENVPN_KEYS/$CN.crt ]
    then echo "Error: certificate with the CN $CN alread exists!"
        echo "    $OPENVPN_KEYS/$CN.crt"
    exit
fi

# Enter the easy-rsa directory and establish the default variables
cd $OPENVPN_RSA_DIR
source ./vars &gt; /dev/null
export KEY_CN="$CN"

# Copied from build-key script (to ensure it works!)
export EASY_RSA="${EASY_RSA:-.}"
"$EASY_RSA/pkitool" --batch $CN

# cat keys and certs inline the .opvn file for easier exchange
DEFAULT="default.ovpn"
FILEEXT=".ovpn"
CRT=".crt"
CSR=".csr"
KEY=".key"
CA="ca.crt"
TA="ta.key"

#1st Verify that client's Public Key Exists
cd $OPENVPN_KEYS
if [ ! -f $CN$CRT ]; then
 echo "[ERROR]: Client Public Key Certificate not found: $CN$CRT"
 exit
fi
echo "Client's cert found: $CN$CR"

#Then, verify that there is a private key for that client
if [ ! -f $CN$KEY ]; then
 echo "[ERROR]: Client Private Key not found: $CN$KEY"
 exit
fi
echo "Client's Private Key found: $CN$KEY"

#Confirm the CA public key exists
if [ ! -f $CA ]; then
 echo "[ERROR]: CA Public Key not found: $CA"
 exit
fi
echo "CA public Key found: $CA"

#Confirm the tls-auth ta key file exists
if [ ! -f $TA ]; then
 echo "[ERROR]: tls-auth Key not found: $TA"
 exit
fi
echo "tls-auth Private Key found: $TA"

#Ready to make a new .opvn file - Start by populating with the default file
cd $KEY_DOWNLOAD_PATH
cat $OPENVPN_RSA_DIR/$DEFAULT &gt; $CN$FILEEXT

#Now, append the CA Public Cert
echo "&lt;ca&gt;" &gt;&gt; $CN$FILEEXT
cat $OPENVPN_DIR/$CA &gt;&gt; $CN$FILEEXT
echo "&lt;/ca&gt;" &gt;&gt; $CN$FILEEXT

#Next append the client Public Cert
echo "&lt;cert&gt;" &gt;&gt; $CN$FILEEXT
cat $OPENVPN_KEYS/$CN$CRT &gt;&gt; $CN$FILEEXT
echo "&lt;/cert&gt;" &gt;&gt; $CN$FILEEXT

#Then, append the client Private Key
echo "&lt;key&gt;" &gt;&gt; $CN$FILEEXT
cat $OPENVPN_KEYS/$CN$KEY &gt;&gt; $CN$FILEEXT
echo "&lt;/key&gt;" &gt;&gt; $CN$FILEEXT

#Finally, append the TA Private Key
echo "key direction 1" &gt;&gt; $CN$FILEEXT
echo "&lt;tls-auth&gt;" &gt;&gt; $CN$FILEEXT
cat $OPENVPN_DIR/$TA &gt;&gt; $CN$FILEEXT
echo "&lt;/tls-auth&gt;" &gt;&gt; $CN$FILEEXT

# Take the new cert and place it somewhere it can be downloaded securely
chmod 666 $CN$FILEEXT
rm $OPENVPN_KEYS/$CN$CRT
rm $OPENVPN_KEYS/$CN$KEY
rm $OPENVPN_KEYS/$CN$CSR
</code></pre>

<p>Dieses Skript benötigt eine <code>default.ovpn</code> Datei in der die Standard Konfiguration enthalten ist bis auf die Client Schlüssel.</p>

<pre><code class="bash">sudo su
cd /etc/openvpn/easy-rsa/
nano default.ovpn
</code></pre>

<pre><code class="bash">mode client

# interface to use for vpn
dev tun

# protocol to use for vpn
proto udp

# hostname/ip of vpn server
remote nilslutz.de 1194 

# hostname lookup of vpn server
resolv-retry infinite 

# no local port bind is necessary
nobind

# persistance
persist-key
persist-tun

# compression
comp-lzo

# logging
verb 3

# cipher suites
cipher AES-256-CBC
auth SHA512
tls-cipher DHE-RSA-AES256-SHA

# server cert verification
remote-cert-tls server

# public/private keys and CA
</code></pre>

<p>Nachdem auch dieses Skript angelegt ist lassen sich damit Client Konfigurationen anlegen.</p>

<pre><code class="bash">./build-client-config &lt;CLIENT NAME&gt;
</code></pre>

<p>Die damit erstelle <code>.ovpn</code> Datei kann dann an den Client weitergegeben werden. Ob nun über eine Website, Mail oder sonstiges ist jedem selbst überlassen.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Umstieg von Wordpress auf Octopress]]></title>
    <link href="http://nlsltz.github.io/2014/09/04/umstieg-von-wordpress-auf-octopress/"/>
    <updated>2014-09-04T17:05:46+02:00</updated>
    <id>http://nlsltz.github.io/2014/09/04/umstieg-von-wordpress-auf-octopress</id>
    <content type="html"><![CDATA[<p><img class="right" src="/images/octopress.png" width="200" height="200" title="&lsquo;Octopress Logo&rsquo; &lsquo;Octopress Logo&rsquo;" >Nach 7 Monaten der erste Beitrag wieder. Irgendwie war mir Wordpress zu klobig, zu vollgestopft mit Plugins. Octopress kannte ich schon etwas länger und es gefiel mir direkt als ich den ersten Blog damit gesehen habe. Optisch sehr schlicht und einfach gehalten zeigt Octopress seine wahre Stärke in der einfachheit im Backend. Wer sich auf der Shell zuhause fühlt ist mit <a href="http://www.octopress.org/">Octopress</a> auf jedenfall gut beraten.<!-- more --></p>

<p>Das ganze ging relativ einfach. Im Wordpress Backend die Export Funktion genutzt um ein XML-File mit sämtlichen Posts zu generieren. Anschließend habe ich die <a href="https://github.com/imathis/octopress">Github Repo von Octopress</a> geforked, da ich spätere Änderungen am Blog gern so sichern würde. Den restlichen Blog habe ich nach dem Octopress Start Guide durchgeführt.
<code>bash
git clone https://github.com/nlsltz/octopress.git octopress
cd octopress
gem install bundler
bundle install
rake install
</code>
Über ein kleines <a href="https://github.com/thomasf/exitwp">Python Script</a> habe ich meine exportierten Posts in das Markdown Format von Octopress umgewandelt. Die umgewandelten Posts nur noch in <code>octopress/source/_posts/</code> eingefügt und den Befehl zum erstellen des Blogs abgesetzt.
<code>bash
rake generate
</code>
Nun findet sich im <code>public</code> Ordner der gesamte erstellte Blog, fertig für den Webserver zum verteilen. Über die drei <code>rake</code> Befehle lässt sich Octopress am Terminal bedienen,
<code>bash
rake generate # blog erstellen
rake preview  # preview der Posts
rake watch    # live tracking von änderungen
</code></p>

<p>Als nächstes möchte ich dem Blog noch ein neues Theme und ein paar Plugins verpassen.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Default User und Swap Grösse des Raspberry Pi ändern]]></title>
    <link href="http://nlsltz.github.io/2014/02/09/default-user-und-swap-grosse-des-raspberry-pi-andern/"/>
    <updated>2014-02-09T17:42:43+01:00</updated>
    <id>http://nlsltz.github.io/2014/02/09/default-user-und-swap-grosse-des-raspberry-pi-andern</id>
    <content type="html"><![CDATA[<p>Es regnet, schmuddel Wetter - also Raspberry Pi ausgepackt und bisschen was dran basteln. Da ich vor habe, meinen Raspi später einmal auch über das Internet erreichbar zu machen, soll der Standard User von <code>pi</code> in einen beliebigen Namen meiner Wahl abgeändert werden. Das erschwert zum einen möglichen Angreifern den Zugang, da sie zusätzlich zum Passwort auch noch den User ermitteln müssten, und zum anderen mag ich es einfach lieber wenn auf all meinen Geräten mein User den selben Namen trägt. Außerdem habe ich mir gedacht, wenn ich schon mal dabei bin erhöhe ich doch direkt die Swap Grösse, welche in der Standard Konfiguration vom Raspbian OS auf 100 MByte gesetzt wird. So am Rande, die <a href="https://wiki.debian.org/Swap">Swap Datei</a> - unter Windows auch gerne Auslagerungsdatei genannt - ist eine Art virtueller Arbeitsspeicher zusätzlich zum schon vorhandenen physischen Arbeitspeicher. Später soll mein Raspi einen Webserver inklusive einer Datenbank, ein kleines Wiki und vermutlich eine private Dropbox alternative beherbergen. Damit diese Services den Kleinen nicht direkt in Knie zwingen, die Erhöhung der Swap Datei.<!-- more --></p>

<p>So kommen wir zum eingemachten. Starten werde ich mit dem Ändern des Default User. Wir benötigen einen extra User kurzzeitig, von welchem aus wir dann den eigentlichen User bearbeiten werden. Für diesen User soll auch kein extra <code>/home/</code> Verzeichnis angelegt werden, da unnötig.
<code>bash
sudo adduser --no-create-home interim
</code>
Dieser neu erstellte User wird noch in die <code>sudoers</code> Liste eingetragen, damit er sich zeitweilig Root-Rechte über das <code>sudo</code> Kommando holen darf. Anschließend kann die Liste gespeichert(Strg+O) und geschlossen(Strg+X), sowie sich komplett vom Raspi abgemeldet werden.
<code>bash
sudo visudo
</code>
<code>bash
interim ALL=(ALL) NOPASSWD: ALL
</code>
Jetzt meldet man sich mit dem eben erstellten <code>interim</code> User wieder an. Der <code>pi</code> User wird dann durch folgenden Befehl umbenannt. Das <code>/home/</code> Verzeichnis nehmen wir direkt mit, damit vorher dort gespeicherte Daten nicht verloren gehen. In meinem Fall soll der <code>pi</code> User in <code>ikarus</code> umbenannt werden. Jeder User hat auch noch seine eigene Gruppe mit selbem Namen, daher müssen wir diese auch mit umbenennen.
<code>bash
sudo usermod --move-home --login ikarus --home /home/ikarus pi
sudo groupmod -n ikarus pi
</code>
Ist das vollbracht löschen wir aus der <code>sudoers</code> Liste noch den vorhin eingetragenen <code>interim</code> User und natürlich ändern wir den <code>pi</code> User so ab, dass er auf den von uns gewählten neuen User passt.
<code>bash
sudo visudo
</code>
<code>bash
pi ALL=(ALL) NOPASSWD: ALL     #pi ändern zu ikarus
interim ALL=(ALL) NOPASSWD:ALL #kann wieder gelöscht werden
</code>
So noch den <code>interim</code> User und Gruppe löschen und dann sind wir damit auch fast fertig. Lediglich zwei Einträge im <code>raspi-config</code> Script und in der <code>lightDM</code> Konfiguration müssen wir noch vom <code>pi</code> User auf den Neuen ändern. Innerhalb von Nano lässt sich über <code>Strg+W</code> leicht die Textpassage suchen.
<code>bash
sudo deluser interim &amp;&amp; sudo delgroup interim
sudo sed /etc/lightdm/lightdm.conf -i -e "s/^#autologin-user=.*/autologin-user=ikarus/"
sudo nano /usr/bin/raspi-config
</code>
<code>bash
if id -u pi &gt; /dev/null 2&gt;&amp;1; then
</code>
zu
<code>bash
if id -u ikarus &gt; /dev/null 2&gt;&amp;1; then
</code>
Zum Schluss noch eben das <code>raspi-config</code> Script aufgerufen und unter dem Punkt <code>Enable Boot to Desktop/Scratch</code> die Option <code>Desktop Log in as user ‘pi’ at the graphical desktop</code> bestätigen. Die <code>raspi-config</code> kann danach direkt erneut aufgerufen werden um den Boot zur Konsole wieder einzustellen. Ein Reboot besiegelt das ganze.
<code>bash
sudo raspi-config
sudo reboot
</code>
Um die Swap Grösse zu ändern reichen 5 einfache Shell Kommandos aus. Beginnen wir damit uns als Root User anzumelden, gefolgt von der Angabe der Grösse, des neuen Swap, und dem generieren dieser Swap Datei. Als Faustregel gilt <strong>SWAP = Arbeitspeicher * 2</strong>, demnach stelle ich für meinen Raspi eine Swap Grösse von 1024 MByte ein.
<code>bash
sudo echo "CONF_SWAPSIZE=1024" &gt; /etc/dphys-swapfile
sudo dphys-swapfile setup
</code>
Die Swap Datei wurde generiert und wird mit folgendem Kommando noch aktiviert. Danach kann man sich als Root User wieder abmelden.
<code>bash
sudo dphys-swapfile swapon
exit
</code>
Tadaaa, wir haben unserem Raspi einen neuen Usernamen verpasst und seinen Swap erhöht.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hello World!]]></title>
    <link href="http://nlsltz.github.io/2014/02/07/hello-world/"/>
    <updated>2014-02-07T16:29:41+01:00</updated>
    <id>http://nlsltz.github.io/2014/02/07/hello-world</id>
    <content type="html"><![CDATA[<p><img class="right" src="/images/2014-02-07-16-15-32.jpg" width="350" height="350" title="&lsquo;Mein Raspberry Pi&rsquo; &lsquo;Mein Raspberry Pi&rsquo;" >Da ist er nun, mein erster Beitrag in meinem eigenen Blog. Gute 2 Jahre hat es gedauert bis ich mich dazu durch gerungen habe ihn tatsächlich zu erstellen. Wie der Blog Titel schon verrät will ich hier immer mal wieder meine Errungenschaften mit Linux, dem Raspberry Pi, Android sowie sonstigem Kram nieder schreiben. Den Anfang machen möchte ich mit einer kleinen Step-to-Step Anleitung wie ich meinen Raspberry Pi als PHP Webserver eingerichtet habe.<!-- more --></p>

<p>Kurz für alle die nicht wissen was ein Raspberry Pi ist. Das ist ein kleiner Einplatinen-Computer, angetrieben von einer 700 MHz ARM CPU mit 512 MB RAM, einem Grafikchip der die Videoausgabe auch in 1080p Full HD schafft. Als Speicher kommt eine SD Karte zum Einsatz, zusätzlich lassen sich über die beiden USB 2.0 Ports noch weitere Medien anschließen. An meinem Pi hängt noch ein USB Hub mit externer Stromzufuhr um nicht auf die beiden vorhandenen Ports limitiert zu sein.</p>

<p>Soviel zum Pi selbst kommen wir nun zur Einrichtung des Webservers. Ich habe mich nach ein wenig Recherche auf Google dazu entschlossen <a href="http://wiki.nginx.org/Main">Nginx</a> einzusetzen, da der Apache wohl zu <a href="http://www.jeremymorgan.com/blog/programming/raspberry-pi-web-server-comparison/">Ressourcen hungrig</a> ist. Als erstes mal über SSH auf den Pi verbinden. In meinem Fall ist der User <code>root</code> und mein Pi im Netzwerk als <code>raspberrypi</code> bekannt.
<code>bash
ssh root@raspberrypi
</code>
Auf dem Pi selbst aktualisieren wir die Paketlisten und installieren dann mit <code>apt</code> den Webserver Nginx und PHP mit ein paar Erweiterungen.
<code>bash
sudo apt-get update &amp;&amp; sudo apt-get install nginx php5 php5-fpm php-apc php5-mcrypt php5-cli php5-gd
</code>
Nachdem Nginx inkl. seiner Abhängigkeiten installiert wurde optimieren wir als erstes die sog. Worker Prozesse &amp; Connections um sie an den Pi anzupassen. Dies geht mittels <code>sed</code> oder Manuell in der Datei <code>/etc/nginx/nginx.conf</code>.
<code>bash
sudo sed -i "s/worker_processes 4;/worker_processes 1;/g" /etc/nginx/nginx.conf
sudo sed -i "s/worker_connections 768;/worker_connections 128;/g" /etc/nginx/nginx.conf
</code>
Nun noch den Webserver starten mittels folgendem Befehl und dann im Browser über die IP Adresse des Pi schauen ob ein <em>Welcome to nginx</em> einem bestätigt das alles läuft.
<code>bash
sudo service nginx restart
</code>
Der Webserver verrichtet seinen Dienst, allerdings ist er noch absolut jungfräulich was seine Einstellungen betrifft. Das ändern wir jetzt. Um zu verstehen wieso wir das tun was wir jetzt tun muss man wissen wie Nginx arbeitet. Beim Start des Dienstes überprüft Nginx den Ordner <code>/etc/nginx/sites-enabled/</code> nach Konfigurationsdateien für die <a href="http://de.wikipedia.org/wiki/Virtual_Hosting">vHosts</a>. Üblicherweise werden in diesem Ordner aber keine Dateien selbst liegen sondern nur Symlinks die auf die Konfigdateien im Ordner <code>/etc/nginx/sites-availabe/</code> verweisen. Will man beispielsweise eine Seite nicht mehr weiter verteilen reicht es völlig aus dessen Symlink zu entfernen. Weiter ist die Standard Konfiguration nicht grade optimal, in Bezug auf den Speicherort der ausgelieferten Seite. Im großen Linux Universum hat sich das Verzeichnis <code>/var/www/</code> als de Facto Standard entpuppt, Nginx zeigt jedoch im auslieferungszustand auf <code>/usr/share/nginx/www/</code>. Diese Unstimmigkeiten ändern wir nun. Außerdem konfigurieren wir den PHP Support damit Nginx auch dynamische Webseiten, die mit PHP erstellt wurden, ausliefern kann.</p>

<p>Stoppen wir zuerst den Webserver und entfernen den Symlink des Standard vHost.
<code>bash
sudo service nginx stop
sudo unlink /etc/nginx/sites-enabled/default
</code>
Jetzt legen wir einen neuen vHost in <code>/etc/nginx/sites-availabe/mysite</code> mit folgendem Inhalt an. Dadurch lauscht Nginx auf Port 80 und verteilt im Falle einer Anfrage die Dateien aus dem Verzeichnis <code>/var/www/</code>. Der <code>location</code> Block ist für den PHP Support zuständig. Er sagt Nginx das jegliche Anfragen die auf <code>.php</code> enden an den PHP Interpreter weiter gereicht werden. 
<code>bash
sudo touch /etc/nginx/sites-availabe/mysite
</code>
&#8220;` bash Nginx Site Config File
server {
        listen 80;
        root /var/www;
        index index.php index.html index.htm;</p>

<pre><code>    location ~ [^/].php(/|$) {
            try_files $uri =404;
            fastcgi_split_path_info ^(.+?.php)(/.*)$;
            fastcgi_pass unix:/var/run/php5-fpm.sock;
            fastcgi_index index.php;
            include fastcgi_params;
    }
</code></pre>

<p>}
<code>
So nun [symlinken](http://wiki.ubuntuusers.de/ln#Symbolische-Verknuepfungen) wir noch den erstellten vHost in den Ordner `/etc/nginx/sites-enabled/`, deaktivieren in der `php.ini` den `CGI.PATH_INFO` fix und starten Nginx und PHP5-FPM.
</code> bash
sudo ln -s /etc/nginx/sites-available/mysite /etc/nginx/sites-enabled/mysite
sudo sed -i &ldquo;s/^;cgi.fix_pathinfo=1/cgi.fix_pathinfo=0/&rdquo; /etc/php5/fpm/php.ini
sudo service php5-fpm restart
sudo service nginx restart
<code>``
Jetzt kann jede Webseite Seite, die im Ordner</code>/var/www/` liegt, von Nginx verteilt werden.</p>

<p>Er ist doch um einiges länger geworden als ich zu erst gedacht hatte, aber gut :)</p>
]]></content>
  </entry>
  
</feed>
